---
title: 'Git - חלק 3'
author: nirgn
layout: post
category: Git
---
[<img class="alignleft wp-image-1488" src="http://www.lifelongstudent.net/wp-content/uploads/2014/06/Git_Logo.png" alt="Git Logo" width="350" height="146" />](http://www.lifelongstudent.net/wp-content/uploads/2014/06/Git_Logo.png)בחלק השלישי של סדרת Git נעבור על שתי תרחישים שונים של שיתופי פעולה, בהם לא הכל עובד חלק כמו שהיה בחלק הקודם (החלק השני). לאחר מכן נמשיך לנושא הענפים המרוחקים (בדומה למאגרים מרוחקים), עבודה משותפת על אותו ענף, הסרה של ענפים וכ'ו, ולבסוף נעבור על טאגים (tags).

אני מזכיר שוב, חלק זה הנו המשך ישיר של החלק הקודם, נמשיך מאותו המקום, עם אותן הדוגמאות וכ'ו. בנוסף, מכיוון שהסדרה הזו מהווה מעין יומן מסע, גם הפוסט הזה יחולק לשניים, יהיו שני חלקים של שאלות ותשובות וסיכום ביניים.

<!--more-->

&nbsp;

## <span style="text-decoration: underline;"><strong>תרחיש ראשון</strong></span>

[<img class="alignleft size-full wp-image-2166" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario.png" alt="first scenario" width="153" height="131" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario.png 153w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario-150x128.png 150w" sizes="(max-width: 153px) 100vw, 153px" />](http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario.png)נניח שאליס דחפה את הפרויקט שלה ל GitHub, ובוב רוצה עותק של הפרויקט, הוא ישבט אותו עם הפקודה '<span style="color: #ff0000;"><git clone <URL</span>'. לאחר מכן אליס תבצע כמה שינויים בפרויקט (נניח שהוסיפה קובץ חדש בשם words.txt עם הפקודה '<span style="color: #ff0000;">git add &#8212; all</span>', לאחר מכן ביצעה לו commit עם הפקודה '<span style="color: #ff0000;">"git commit -m "Add words.txt</span>' ולבסוף דחפה את השינויים ל GitHub עם הפקודה '<span style="color: #ff0000;">git push</span>'). כעת נעבור לבוב, בוב עבד בזמן שאליס עשתה את השינויים שלה, ועשה שינויים משלו (שינויים בקובץ קיים, שמהערכת כבר עוקבת אחריו, וביצע commit עם הפקודה '<span style="color: #ff0000;">"git commit -m -a "Update the readme</span>'). אז כעת יש לנו את ה commit של אליס שכבר עודכן ב GitHub ואת ה commit של בוב, שיושב ב repo המקומי שלו (במחשב שלו), והם שונים (ניתן לראות בתמונה משמאל ייצוג וויזואלי שהכנתי לענפים/צירי הזמן של אליס ובוב).

אז מה יקרה אם בוב ינסה לדחוף את ה commit שלו ל GitHub? כמו שניתן לראות בקוד למטה, הוא ידחה. ולפי התיאור, ניתן לקרוא כי הוא נדחה בשל כך שהקצה של הענף שלו (ה commit האחרון בענף שלו) שונה מזה שבענף המרוחק.

<pre class="lang:ps decode:true">nirgn $ git push
To http://github.com/example/test.git
![rejected] master -&gt; master (non-fast-forward)
error:failed to push some refs to 'http://github.com/example/test.git'
hint: Update were rejected because the tip of your current branch is behind
hint: it's remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</pre>

לכן בוב יצטרך לסנכרן את הפרויקט שלו עם הפקודה '<span style="color: #ff0000;">git pull</span>' ורק אז לדחוף את הפרויקט (עם ה commit) שלו ל GitHub עם הפקודה '<span style="color: #ff0000;">git push</span>'. אבל האם סנכרון הפרויקט שלו לא פוגע בשינויים שביצע? לא. בואו נראה מה קורה מתחת למכסה המנוע כשאנו מבצעים '<span style="color: #ff0000;">git push</span>':

  1. [<img class="alignleft wp-image-2168" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/firstStep.png" alt="firstStep" width="225" height="116" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/firstStep.png 254w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/firstStep-150x77.png 150w" sizes="(max-width: 225px) 100vw, 225px" />](http://www.lifelongstudent.net/wp-content/uploads/2014/08/firstStep.png)קודם כל, המערכת מביאה את ה repo המקומי שלנו לאותה הנקודה ב repo המרוחק (ז"א לוקחת את ה commit של אליס ומביא אותו לענף של בוב). חשוב לציין כי זה רק מביא את ה commit, ולא באמת מעדכן את הקוד המקומי שלנו. אם נרחיב את נקודת המבט בענף של בוב, נראה (כמו בתמונה משמאל) שבעצם יתפצל מה commit הזה ענף חדש, בשם origin/master שמייצג את ה repo המרוחק שלנו. בנוסף, הצעד הראשון זהה לכתיבת הפקודה '<span style="color: #ff0000;">git fetch</span>'. <pre class="lang:ps decode:true">nirgn $ git fetch
	remote: Counting objects: 5, done.
	remote: Compressing objects: 100% (2/2), done.
	remote: Total 4 (delta 0), reused 4 (delta 0)
	Unpacking objects: 100% (4/4), done.
	From http://github.com/nirgn975/test.git
		f35f2f1..71a4650 master -&gt; origin/master</pre>

  2. <img class="alignleft wp-image-2170" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepThree.png" alt="stepThree" width="160" height="145" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepThree.png 209w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepThree-150x136.png 150w" sizes="(max-width: 160px) 100vw, 160px" />בצעד השני המערכת ממזגת את הענף origin/master עם הענף master (כמו להריץ את הפקודה '<span style="color: #ff0000;">git merge origin/master</span>'). אם אתם זוכרים, בפוסט הקודם כשביצענו איחוד בין 2 ענפים עם commit שונה בכל אחד מהם, המערכת ישר הקפיצה לנו עורך בו היינו צריכים ליצור commit מאוחד. לאחר שיצאנו מהעורך, המערכת הדפיסה לנו טקסט ובאחת השורות נכתב כי בוצע "מיזוג רקורסיבי" (השורה: Merge made by the 'recursive' strategy).
  3. אם נסתכל כעת בציר הזמן (תמונה משמאל) נראה כי ישנו commit חדש, שמו יהיה "merge commit". תשימו לב כי הענף origin/master עדיין לא מודע לשינויים של בוב ול merge commit.
  4. <img class="alignleft wp-image-2171" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepFour.png" alt="stepFour" width="160" height="145" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepFour.png 209w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/stepFour-150x136.png 150w" sizes="(max-width: 160px) 100vw, 160px" />בשלב הבא המערכת תבצע '<span style="color: #ff0000;">git push</span>' ובשלב הזה origin/master יצביע ל master (ולכן ידע על השינויים וה merge commit), והכל יעודכן.

כעת, אם נחזור קצת אחורה, לאחר שכתבנו את הפקודות '<span style="color: #ff0000;">git pull</span>' ו '<span style="color: #ff0000;">git push</span>', נבדוק את הלוג (עם הפקודה '<span style="color: #ff0000;">git log</span>') ונראה את ה merge commit.

<pre class="lang:ps decode:true">nirgn $ git log
	commit ee47baaedcd54e1957f86bda1aaa1b8a136185da
	Merge: 87c5243 57501d5
	Author: Nir Galon &lt;nirgn975@gmail.com&gt;				&lt;!-------- Merge Commit !!!!

		Merge branch 'master' of https://github.com/nirgn975/test.git

	commit 87c5243d2266f05cd9fda8b1c9137f11b3fe6f31
	Author: Nir Galon &lt;nirgn975@gmail.com&gt;

		Update the readme.

	commit 57501d595b16e2d1198a9c04c547a5b1380a6618
	Author: Nir Galon &lt;nirgn975@gmail.com&gt;

		Add store and product models.</pre>

יש ברשת כמה דעות, ותוכלו בקלות למצוא אנשים שלא ממש מחבבים את ה merge commit, מכיוון שאם ישנו הרבה שיתוף פעולה בפרויקט חי (כזה שזז לעיתים קרובות ע"י כמה אנשים בו זמנית), תוכלו לראות אחוז נכבד מהשינויים בלוג כ merge commit, וזה די מטנף את הלוג. כרגע נשאיר את זה ככה, בהמשך נדבר על משהו שנקרא rebase, שזו אחת מהדרכים לעקוף את ה merge commit.

&nbsp;

## <span style="text-decoration: underline;"><strong><img class="alignleft size-full wp-image-2166" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario.png" alt="first scenario" width="153" height="131" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario.png 153w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/first_scenario-150x128.png 150w" sizes="(max-width: 153px) 100vw, 153px" />תרחיש שני</strong></span>

כעת, נניח שאליס ובוב עובדים שוב על אותו הקוד באותו הזמן, רק שהפעם הם עובדים על אותו הקובץ, נניח קובץ ה README. שוב, אליס ביצעה את השינויים ודחפה את ה commit ל repo המרוחק, GitHub, ובוב רק ביצע commit (נשאר באופן מקומי). כעת, כמו בתמונה הראשונה בתרחיש הראשון, יש לנו שתי commit, אחד ב GitHub והשני מקומי, ושניהם שונים אחד מהשני (בעוד אלה שלפניהם זהים).

מה יקרה הפעם אם בוב ידחוף את ה commit שלו לאותו ה repo המרוחק שמאוחסן ב GitHub? הפעם אנחנו מנוסים, נדלג על הטעויות שביצענו בתרחיש הקודם ובוב יבצע ישר '<span style="color: #ff0000;">git pull</span>' (זה מביא את ה repo המקומי לאותה הנקודה כמו ב repo המרוחק (מושך את ה commit של אליס) ואז הוא מנסה למזג את הענפים), אך כאן המיזוג יכשל, ישנו קונפליקט והמערכת כותבת לנו איפה הוא נמצא (ניתן לראות שבקובץ README.txt), לכן נהיה חייבים לערוך את קובץ ה README, מכיוון שהמערכת זורקת אותנו חזרה לשורת הפקודה.

אם נכתוב בשורת הפקודה '<span style="color: #ff0000;">git status</span>', נראה שהמערכת אומרת לנו שבענף שלנו ובענף "origin/master" בוצע שינוי באותו קובץ, README.txt ולכן, שוב, אנחנו חייבים לערוך את הקובץ ורק אז לעשות merge commit. אם בנקודה הזאת נעבור ל README.txt משהו שנראה כמו diff, יהיה שם קטע ערוך ובו השורות קוד של בוב, חוצץ (בדמות ====), והשורות קוד של אליס (כל זה בין >>>> ל <<<<). ונצטרך לערוך את הקוד ידנית כדי לתקן אותו, נמחק את הקוד המיותר, וכשסיימנו נשמור ונכתוב בשורת הפקודה '<span style="color: #ff0000;">git commit -a</span>' (או '<span style="color: #ff0000;">git add &#8211;all</span>') והמערכת תפתח את העורך, המערכת תכתוב לנו את ההודעה שתהיה ב commit (כי זהו merge commit) ואפילו תציג את הקבצים איתם היה קונפליקט ותיקנו, כשנשמור הענף יראה כמו בתמונה של שלב 4 בתרחיש הראשון, וכשנבצע '<span style="color: #ff0000;">git push</span>' ה origin/master יסתנכרן (יצביע) ל master.

&nbsp;

## <span style="text-decoration: underline;"><strong>שאלות ותשובות</strong></span>

כמו תמיד, החלק של השאלות והתשובות אינו תחליף לתרגול, אם אין לכם פרויקט שאתם יכולים/רוצים לשתף, צרו תיקייה ובתוכה קובץ טקסט פשוט ותתרגלו. אין תחליף לתרגול אישי במחשב שלכם עם שורת הפקודה. הלמידה הטובה ביותר מגיעה דרך האצבעות, אז כתבו את הפקודות בעצמכם, גם אם אתם לא זוכרים, תנסו, ומקסימום תסתכלו בתשובות. אך תכתבו אותן בעצמכם ואל תתפתו להשתמש ב copy/paste, אחרי כתיבת הפקודה פעם, פעמיים, שלוש זה יגיע.

<span style="text-decoration: underline;"><strong>שאלות:</strong></span>

  1. ביצעתם commit לעבודה שעשיתם, הגיע הזמן לשתף אותה, דחפו אותה לשרת של החברה שלכם (הניחו שזאת לא פעם ראשונה שאתם דוחפים קוד, לכן כבר שמרתם את כתובת ה repo המרוחק).
  2. אופס, הדחיפה שלכם נדחתה, נראה שחבר שלכם לצוות עשה עבודה ודחף אותה, וה repo שלכם כבר אינו מעודכן. סנכרנו את הענף שלכם.
  3. גיט מדווחת על קונפליקט עם השינויים של חברכם לצוות בקובץ index.html, תשמרו את השינויים שלכם, וכתבו תיאור של השינויים שלו כהערה (comment). להלן <a href="http://www.lifelongstudent.net/wp-content/uploads/2015/10/git_conflict_3.png" target="_blank">תמונה</a> של תוכן הקובץ.
  4. הוסיפו את השינויים שעשיתם (בפתירת הקונפליקט שהיה ב index.html) ל commit.
  5. לבסוף, בצעו commit לשינויים במיזוג (אלה שביצעתם כדי לפתור את הקונפליקט), אל תשכחו להוסיף תיאור כדי שנדע על מה ה commit.

**<span style="text-decoration: underline;">תשובות:</span>**

  1. הפקודה: '<span style="color: #ff0000;">git push</span>'.
  2. הפקודה: '<span style="color: #ff0000;">git pull</span>'.
  3. התמונה של תוכן הקובץ (index.html) אחרי העריכה.
  4. הפקודה: '<span style="color: #ff0000;">git commit -a</span>' או '<span style="color: #ff0000;">git add &#8211;all</span>'.
  5. הפקודה: '<span style="color: #ff0000;">"git commit -a -m "Merge changes</span>'.

&nbsp;

## <span style="text-decoration: underline;"><strong>סיכום ביניים</strong></span>

עברנו על שני תרחישים לשיתוף פעולה מורכב בין חברי צוות, ראינו בדיוק את התהליך שמתבצע כשאנו כותבים את הפקודה '<span style="color: #ff0000;">git pull</span>', ומה צריך לעשות כדי להתגבר על שינויים שבוצעו בו זמנית בקבצים שונים, ואף שינויים שבוצעו באותו הקובץ.

&nbsp;

## <span style="text-decoration: underline;"><strong>ענפים מרוחקים</strong></span>

בחלק הקודם דיברנו על ענפים מקומיים, כאלה שאנחנו יוצרים ב repo המקומי שלנו, אך מה לגבי ענפים בפרויקטים מרוחקים? (remote branch). יכול להיות מצב בו יהיה לנו ענף, נניח ענף admin, ואנחנו רוצים לאפשר לאנשים אחרים לעבוד עליו. אנחנו נצטרך לדחוף את הענף הזה כדי שאנשים אחרים גם יוכלו לגשת אליו, ולעבוד אליו עד שניתן למזגו עם master. בנוסף, אם אנחנו עובדים על ענף עם פרויקט די גדול, שימשך קצת זמן, בואו נגיד כמה ימים ומעלה, כנראה שנרצה לגבות אותו, שישמר בעוד מקום מעבר לרק ב repo המקומי שלנו. דחיפת הענף עונה גם על צורך זה ומאפשרת לגבות אותו, לדוגמה ב GitHub.

נניח שאליס רוצה לעבוד על אזור חדש באתר בשם profile. היא יצרה ענף חדש בשם זה בעזרת הפקודה '<span style="color: #ff0000;">git checkout -b profile</span>' (כדי ליצור את הענף ולעבור אליו בפקודה אחת), וכדי לדחוף את הענף ל GitHub כתבה '<span style="color: #ff0000;">git push origin profile</span>'. וזה בעצם מקשר בין הענף המקומי לענף המרוחק (המגובה ב GitHub) ומתחיל לעקוב אחריו.

<pre class="lang:default decode:true">$ git checkout -b prfile
  Switched to a new brnach ‘progile’

$ git push origin profile
  Counting objects: 10, done.
  Delta compression using up to 4 threads.
  Compressing objects: 100% (6/6), done.
  writing objects: 100% (6/6), 619 bytes, done.
  Total 6 (delta 2), reused 0 (delta 0)
  To http://github.com/nirgn975/test.git
    * [new branch]     profile -&gt; profile</pre>

[<img class="alignleft wp-image-2267" src="http://www.lifelongstudent.net/wp-content/uploads/2014/08/github_branches_tags.png" alt="github_branches_tags" width="280" height="159" srcset="http://www.lifelongstudent.net/wp-content/uploads/2014/08/github_branches_tags.png 400w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/github_branches_tags-150x85.png 150w, http://www.lifelongstudent.net/wp-content/uploads/2014/08/github_branches_tags-300x170.png 300w" sizes="(max-width: 280px) 100vw, 280px" />](http://www.lifelongstudent.net/wp-content/uploads/2014/08/github_branches_tags.png)בואו נגיד שאליס עשתה כמה שינויים, הוסיפה דף בשם profile.html עם הפקודה '<span style="color: #ff0000;">git add profile.html</span>', ביצעה לו commit בעזרת הפקודה '<span style="color: #ff0000;">"git commit -a -m "Create profile page</span>', ואז נבצע push, כי זה ענף שאחריו המערכת כבר עוקבת (עם הפקודה '<span style="color: #ff0000;">git push</span>') ולכן הוא יודע לדחוף את הענף profile המקומי לענף profile המרוחק. אם נקפוץ לאתר GitHub, נשים לב שבתוך הפרויקט שלנו ישנו כפתור בשם "&#8230; :branch", כשנלחץ עליו תפתח לנו רשימה של כל הענפים (בתמונה משמאל ניתן לראות רק ענף אחד, בשם "gh-pages"), כשנלחץ על הענף נראה את תיאור ה commit האחרון ומתחתיו את הקבצים שנמצאים בענף).

<pre class="lang:ps decode:true">$ git add profile.html
$ git commit -a -m "Create profile page"
  [profile 2a0dbf9] Create profile page
  1 file changed, 1 insertion(+)
  create mode 100644 profile.html

$ git push
  Counting objects: 4, done.
  Delta compression using up to 4 threads.
  Compressing objects: 100% (2/2), done.
  Writing objects: 100% (3/3), 302 bytes, done.
  Total 3 (delta 1), reused 0 (delta 0)
  To https://github.com/nirgn975/test.git
    786d7a1..2a0dbf9     profile -&gt; profile</pre>

עכשיו, אחרי שאליס יצרה את הענף ודחפה אותו, יצרה את הקובץ הרלוונטי ודחפה אותו לענף המרוחק, היא הולכת לבוב חברה לצוות שאחראי על החלק של הפרופיל בפרוייקט, ואומרת לו שהיא יצרה את הענף וכ'ו, והוא יכול להוריד אותו ולהתחיל לעבוד על הדף החדש. אז איך הדברים נראים מנקודת המבט של בוב?

כשבוב יבצע '<span style="color: #ff0000;">git pull</span>' המערכת תראה לו (בפלט) שישנו ענף מרוחק חדש בשם profile. אם הוא יכתוב '<span style="color: #ff0000;">git branch</span>' הוא לא יראה אותו כענף מקומי, אך אם הוא יכתוב '<span style="color: #ff0000;">git branch -r</span>' הוא יראה את הרשימה של כל הענפים המרוחקים (ואת profile בינהם). הוא יוכל לכתוב '<span style="color: #ff0000;">git checkout profile</span>' כדי להתחיל לעבוד על הענף, המערכת, באופן אוטומטי (כתוצאה מכתיבת הפקודה), תוריד את הענף, ותתחיל לעקוב אחריו כענף מרוחק. לכן מפה הוא יכול לבצע את העבודה שלו, וכשהוא מסיים לדחוף את העבודה לענף המרוחק באמצעות הפקודה '<span style="color: #ff0000;">git push</span>'.

אחת הפקודות השימושיות ביותר לעבודה עם ענפים מרוחקים היא הפקודה '<span style="color: #ff0000;">git remote show</span>', כשנכתוב '<span style="color: #ff0000;">git remote show origin</span>' (כש origin הוא השם של ה repo המרוחק), המערכת תראה לנו את כל הענפים המרוחקים בפרויקט, האם המערכת עוקבת אחריהם או לא, את הענפים המקומיים שלנו ולאיזה ענפים מרוחקים הם מסונכרנים (או מתמזגים), ולבסוף, זה יראה לנו למה הענפים המקומיים שלנו מוגדרים כשנבצע '<span style="color: #ff0000;">git push</span>'. בנוסף, כשאנו נכתוב את הפקודה, המערכת אפילו תיגש לשרת ותבדוק אם אחד מהענפים המקומיים שלנו אינו עדכני.

<pre class="lang:ps decode:true ">$ git remote show origin
  * remote origin
    Fetch URL: https://github.com/nirgn975/test.git
    Push  URL: https://github.com/nirgn975/test.git
    HEAD branch: master
    Remote branches:
      master  tracked
      profile tracked
    Local branches configured for 'git pull':
      master  merges with remote master
      profile merges with remote master
    Local refs configured for 'git push':
      master  pushes to master  (up to date)
      profile pushes to profile (local out of date)</pre>

&nbsp;

## <span style="text-decoration: underline;"><strong>הסרה של ענפים מרוחקים</strong></span>

ענפים מרוחקים, בדיוק כמו ענפים מקומיים, אינם כאן כדי להישאר לנצח. כדי למחוק ענף מרוחק נכתוב את הפקודה '<span style="color: #ff0000;"><git push origin:<branchName</span>' ז"א במקרה שלנו אם נרצה למחוק את profile נכתוב '<span style="color: #ff0000;">git push origin :profile</span>'. שימו Kב שהפקודה מוחקת אך ורק את הענף המרוחק, הענף המקומי עדיין יהיה קיים. בסעיף הקודם ראינו שכדי למחוק את הענף המקומי נכתוב '<span style="color: #ff0000;">git branch -d profile</span>', אך אם נכתוב זאת כרגע, נקבל הודעת שגיאה, המערכת לא תתן לנו למחוק את הענף המקומי, למה? כי המחיקה היא של הענף בלבד, המערכת תציין כי ישנם commitים שלא מזגנו לשום מקום (אם באמת נרצה למחוק את הענף, כולל את ה commitים שהוא מכיל נכתוב '<span style="color: #ff0000;">git branch -D profile</span>').

אז בואו נניח שבוב מחק את הענף. אבל הרי אליס היא זאת שיצרה אותו מלכתחילה. מה יקרה אם אליס תנסה לדחוף שינויים ל remote שלא קיים יותר? נניח שאליס עשתה כמה שינויים ומבצעת commit, לדוגמה '<span style="color: #ff0000;">"git commit &#8211; m -a "Add ability to change city</span>' ולאחר מכן היא מנסה לעשות '<span style="color: #ff0000;">git push</span>' כדי לעדכן את ה commit בענף המרוחק. git תחזיר תשובה "Everything up-to-date", בגלל שהענף המרוחק לא קיים, העדכון מתבצע בענף המקומי בלבד ואינו עולה לשרת ב GitHub. כדי לבדוק מה הולך כאן כנראה שאליס תריץ את הפקודה '<span style="color: #ff0000;">git remote show origin</span>' ותראה שהענף המקומי שלה, profile, ישן (באנגלית: stale), מישהו מחק אותו. כדי למחוק את ההפניה המקומית הזאת היא תריץ '<span style="color: #ff0000;">git remote prune origin</span>' ו git תנקה את כל ההפניות והענפים הישנים.

&nbsp;

## <span style="text-decoration: underline;"><strong>Tags</strong></span>

טאגים (tags) הם בעצם התייחסות ספציפית ל commit ספציפי, זהוי דרך טובה לקפוץ למצב בו הקוד היה במצב כלשהו בזמן כלשהו, והרבה מהאנשים משתמשים בזה למספור של גרסאות שחרור. ז"א שאם הקוד שלנו במצב טוב, סיימנו פיצ'ר מרכזי וכד', אולי נשייך אליו tag בשם v0.1 (או משהו כזה).

אז כדי ש git תדפיס לנו רשימה של כל ה טאגים הקיימים בפרוייקט ניתן לכתוב '<span style="color: #ff0000;">git tag</span>'. כדי לבדוק את אחד מהטאגים ולראות איך הקוד היה באותו הזמן נכתוב '<span style="color: #ff0000;"><git checkout <tagName</span>', ז"א שאם נמשיך עם הדוגמה של מס' הגרסה נכתוב '<span style="color: #ff0000;">git checkout v0.1</span>'. כדי להוסיף טאג חדש נכתוב '<span style="color: #ff0000;"><git tag -a <newTagName> -m <tagDescription</span>', לדוגמה '<span style="color: #ff0000;"><git tag -a v0.2 &#8211; "Version 0.2</span>', וכדי לדחוף את הטאגים שלנו נצטרך לכתוב '<span style="color: #ff0000;">git push &#8211;tags</span>', אחרת הטאגים רק ישארו מקומיים.

עכשיו אם תעלו למעלה, לצילום מסך מ GitHub, תראו שליד ה "Branches" ישנו חוצץ בשם "Tags", אם נלחץ עליו נראה את רשימת כל הטאגים ב repo. אם נלחץ על אחד מהטאגים הדף יטען מחדש ונראה את המצב בו הקבצים והקוד היו באותו הטאג.

&nbsp;

## <span style="text-decoration: underline;"><strong>שאלות ותשובות</strong></span>

כמו תמיד, החלק של השאלות והתשובות אינו תחליף לתרגול, אם אין לכם פרויקט שאתם יכולים/רוצים לשתף, צרו תיקייה ובתוכה קובץ טקסט פשוט ותתרגלו. אין תחליף לתרגול אישי במחשב שלכם עם שורת הפקודה. הלמידה הטובה ביותר מגיעה דרך האצבעות, אז כתבו את הפקודות בעצמכם, גם אם אתם לא זוכרים, תנסו, ומקסימום תסתכלו בתשובות. אך תכתבו אותן בעצמכם ואל תתפתו להשתמש ב copy/paste, אחרי כתיבת הפקודה פעם, פעמיים, שלוש זה יגיע.

<span style="text-decoration: underline;"><strong>שאלות:</strong></span>

  1. יצרתם ענף חדש בשם checkout לאזור חדש באתר קניות, פיצ'ר העגלה מוכן וביצעתם לו commit בענף checkout. כעת, פרסמו את הענף הנ"ל ב repo הראשי (בשם origin).
  2. חבר שלכם לצוות הוסיף ענף חדש, תמשכו אותו מה repo המרוחק.
  3. מצוין, משכתם את כל הענפים החדשים, אך חברכם לצוות לא אמר לכם מהו שם הענף החדש, הדפיסו רשימה של כל הענפים.
  4. הפרויקט של חבר שלכם בוטל, תמחקו את הענף (שם הענף blaBla, הקפידו למחוק רק את הענף המרוחק, לא המקומי).
  5. חכו שנייה, כבר משכתם את הענף ל repo המקומי שלכם. תבדקו איזה ענפים נמצאים אצלכם בפרויקט ולאיזה ענפים מרוחקים הם מסונכרנים.
  6. יש לכם עדיין התייחסות לענף blaBla שמחקנו מקודם, נקו את כל ההפניות והענפים הישנים.
  7. עכשיו כשהפרויקט בוטל, אנחנו רוצים לפרסם גרסה חדשה של האתר, אך איזה גרסה נכתוב? תוציאו רשימה של הטאגים כדי שתוכלו לראות את מס' הגרסה האחרון.
  8. אה אוקי, הגרסה האחרונה הייתה v1.0.5, לכן הגרסה הזו תיהיה v1.0.6, צרו טאג לפיכך.
  9. דחפו את הטאג ל origin.
 10. טעות שלי, חזרו לקוד של הטאג v1.0.5.

**<span style="text-decoration: underline;">תשובות:</span>**

  1. הפקודה '<span style="color: #ff0000;">git push origin checkout</span>'. בגלל שהמערכת אינה עוקבת אחר הענף (הוא ענף מקומי בלבד) אנחנו צריכים לפרט את שם ה repo שאליו אנחנו דוחפים (אליו מתבצע הקישור) ואת שם הענף.
  2. הפקודה '<span style="color: #ff0000;">git fetch</span>' תמשוך את כל הענפים החדשים.
  3. הפקודה '<span style="color: #ff0000;">git branch -r</span>'.
  4. הפקודה '<span style="color: #ff0000;">git push origin :blaBla</span>'.
  5. הפקודה '<span style="color: #ff0000;">git remote show origin</span>'.
  6. הפקודה '<span style="color: #ff0000;">git remote prune origin</span>'.
  7. הפקודה '<span style="color: #ff0000;">git tag</span>'.
  8. הפקודה '<span style="color: #ff0000;">"git tag -a v1.0.6 -m "diss tag</span>'.
  9. הפקודה '<span style="color: #ff0000;">git push &#8211;tags</span>'.
 10. הפקודה '<span style="color: #ff0000;">git checkout v1.0.5</span>'.

&nbsp;

## **<span style="text-decoration: underline;">סיכום</span>**

אז עברנו על 2 תרחישים מורכבים של שיתוף פעולה בפרויקט אם זה על קבצים שונים אך באותו הפרויקט (מאגר) או אפילו שינויים באותו הקובץ. לאחר מכן המשכנו לנושא הענפים המרוחקים, מדוע ואיך ליצור אותם, כיצד הם ניראים ב GitHub, כיצד חבר לצוות יראה וישתמש בענף החדש, כיצד למחוק אותם, ומה יקרה אם ננסה לדחוף שינויים לענף שנמחק. בסוף, הזכרנו בקצרה את נושא הטאגים (tags), למה הם מיועדים, איך הם נראים ב GitHub, וכיצד ליצור, להדפיס, ולהשתמש בהם. מקווה שהכל מובן והצלחתם לענות על התשובות (אני יודע שהיו כמה טריקיות בשאלות האחרונות). אם דרוש הסבר ל-למה ככה או למה לא אחרת, אשמח לנסות לעזור בתגובות.
